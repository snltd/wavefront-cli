#!/usr/bin/env ruby

require 'pathname'
require 'docopt'
require 'rest-client'

# uncomment for development
$LOAD_PATH.<< Pathname.new(__FILE__).dirname.realpath.parent + 'lib'
$LOAD_PATH.<< Pathname.new(__FILE__).dirname.realpath.parent.parent + 'wavefront-sdk' + 'lib'

require 'wavefront-cli/version'
require 'wavefront-cli/opt_handler'
include WavefrontCli::Constants

# Mostly we can derive the SDK class from the command, but there's
# some CamelCasing to deal with
#
class_names = {
  cloudintegration: 'CloudIntegration',
  maintenancewindow: 'MaintenanceWindow',
  savedsearch: 'SavedSearch',
}

def sanitize_keys(hash)
  hash.each_with_object({}) { |(k, v), aggr| aggr[k.delete('-').to_sym] = v }
end

WF = Pathname.new(__FILE__).basename

# If we are a normal user, look for wavefront config in our home
# directory; if not, look in /etc
#
conf_file = if ENV['HOME']
              Pathname.new(ENV['HOME']) + '.wavefront'
            else
              Pathname.new('/etc/wavefront/client.conf')
            end

# The global_opts are available in every command.
#
global_opts = %(
Global options:
  -c, --config=FILE    path to configuration file [#{conf_file}]
  -P, --profile=NAME   profile in configuration file [#{DEFAULT_OPTS[:profile]}]
  -D, --debug          enable debug mode
  -n, --noop           don't perform API calls
  -V, --verbose        be verbose
  -h, --help           show this message
)

# options common to nearly all commands
#
CMN = '[-DnV] [-c file] [-P profile] [-E endpoint]
             [-t token]'

# The following hash contains the docopt strings defining all the
# commands we offer. They must include the global_opts.
#
usage = {

agent: %(
Usage:
  #{WF} agent list #{CMN} [-f format] [-S start] [-L limit]
  #{WF} agent describe #{CMN} [-f format] <id>
  #{WF} agent delete #{CMN} <id>
  #{WF} agent undelete #{CMN} <id>
  #{WF} agent rename #{CMN} <id> <name>
#{global_opts}
Options:
  -E, --endpoint=URI        cluster endpoint [#{DEFAULT_OPTS[:endpoint]}]
  -t, --token=TOKEN         Wavefront authentication token
  -S, --start=n             start from nth agent
  -f, --agentformat=STRING  output format (#{AGENT_FORMATS.join(', ')}) [#{DEFAULT_OPTS[:agentformat]}]
  -L, --limit=COUNT        number of agents to report
),

alert: %(
Usage:
  #{WF} alert list #{CMN} [-s] [-f format] [-S start] [-L limit]
  #{WF} alert describe #{CMN} [-f format] [-v version] <id>
  #{WF} alert delete #{CMN} <id>
  #{WF} alert undelete #{CMN} <id>
  #{WF} alert history #{CMN} [-f format] [-S start] [-L limit] <id>
  #{WF} alert import #{CMN} <file>
  #{WF} alert snooze #{CMN} [-t time] <id>
  #{WF} alert unsnooze #{CMN} <id>
  #{WF} alert tags #{CMN} [-f format] <id>
  #{WF} alert tag set #{CMN} <id> <tag>...
  #{WF} alert tag clear #{CMN} <id>
  #{WF} alert tag add #{CMN} <id> <tag>
  #{WF} alert tag delete #{CMN} <id> <tag>
  #{WF} alert summary #{CMN}
  #{WF} alert --help
#{global_opts}
Options:
  -E, --endpoint=URI       cluster endpoint [#{DEFAULT_OPTS[:endpoint]}]
  -t, --token=TOKEN        Wavefront authentication token
  -s, --short              only list alert names and IDs
  -v, --version=INTEGER    describe only this version of alert
  -S, --start=n            start from nth alert
  -L, --limit=COUNT        number of alerts to report
  -T, --time=SECONDS       how long to snooze (default 3600)
  -f, --alertformat=STRING output format (#{ALERT_FORMATS.join(', ')})
                           [#{DEFAULT_OPTS[:alertformat]}]
  -X, --private=TAG        retrieve only alerts with named private tags,
                           comma delimited.
  -Z, --shared=TAG         retrieve only alerts with named shared tags,
                           comma delimited.
),
cloudintegration: %(
Usage:
  #{WF} cloudintegration list #{CMN} [-s] [-f format] [-S start] [-L limit]
  #{WF} cloudintegration describe #{CMN} [-f format] <id>
  #{WF} cloudintegration delete #{CMN} <id>
  #{WF} cloudintegration undelete #{CMN} <id>
  #{WF} cloudintegration --help
#{global_opts}
Options:
  -E, --endpoint=URI       cluster endpoint [#{DEFAULT_OPTS[:endpoint]}]
  -t, --token=TOKEN        Wavefront authentication token
  -s, --short              only list alert names and IDs
),
dashboard: %(
Usage:
  #{WF} dashboard list #{CMN} [-s] [-f format] [-S start] [-L limit]
  #{WF} dashboard import #{CMN} [-f format] [-F] <file>
  #{WF} dashboard export #{CMN} [-f format] [-v version] <id>
  #{WF} dashboard delete #{CMN} <id>
  #{WF} dashboard undelete #{CMN} <id>
  #{WF} dashboard history #{CMN} [-s] [-f format] [-S start] [-L limit] <id>
  #{WF} dashboard tags #{CMN} [-f format] <id>
  #{WF} dashboard tag set #{CMN} <id> <tag>...
  #{WF} dashboard tag clear #{CMN} <id>
  #{WF} dashboard tag add #{CMN} <id> <tag>
  #{WF} dashboard tag delete #{CMN} <id> <tag>
  #{WF} dashboard --help
#{global_opts}
Options:
  -E, --endpoint=URI       cluster endpoint [#{DEFAULT_OPTS[:endpoint]}]
  -t, --token=TOKEN        Wavefront authentication token
  -s, --short              only list dashboard names and IDs
  -S, --start=VERSION      highest version number from which to descend
  -L, --limit=COUNT        number of versions to report
  -v, --version=INTEGER    version of dashboard to clone
  -f, --dashformat=STRING  output format (#{DASH_FORMATS.join(', ')}) [#{DEFAULT_OPTS[:dashformat]}]
),

event: %(
Usage:
  #{WF} event create [-DnV] [-c file] [-P profile] [-E endpoint] [-t token]
           [-d description] [-s time] [-i | -e time] [-l level] [-T type]
           [-H host] [-N] <event>
  #{WF} event close [-DnV] [-c file] [-P profile] [-E endpoint] [-t token]
           [<event>] [<timestamp>]
  #{WF} event delete [-DnV] [-c file] [-P profile] [-E endpoint] [-t token]
           <timestamp> <event>
  #{WF} event show
  #{WF} event --help
#{global_opts}
Options:
  -E, --endpoint=URI   cluster endpoint [#{DEFAULT_OPTS[:endpoint]}]
  -t, --token=TOKEN    Wavefront authentication token
  -i, --instant        create an instantaneous event
  -s, --start=TIME     time at which event begins
  -e, --end=TIME       time at which event ends
  -l, --level=LEVEL    level of event (#{EVENT_LEVELS.join(', ')})
  -T, --type=TYPE      type of event
  -d, --desc=STRING    description of event
  -H, --host=STRING    list of sources to which event applies (comma separated)
  -N, --nostate        do not create a local file recording the event

View events in detail using the 'ts' command with the 'events()' function.
),

write: %(
Usage:
  #{WF} write point [-DnV] [-c file] [-P profile] [-E proxy] [-t time]
           [-p port] [-H host] [-n] [-T tag...] <metric> <value>
  #{WF} write file [-DnV] [-c file] [-P profile] [-E proxy] [-H host]
           [-p port] [-n] [-F format] [-m metric] [-T tag...] <file>
  #{WF} write --help
#{global_opts}
Options:
  -E, --proxy=URI            proxy endpoint [#{DEFAULT_OPTS[:proxy]}]
  -t, --time=TIME            time of data point (omit to use current time)
  -H, --host=STRING          source host [#{DEFAULT_OPTS[:host]}]
  -p, --port=INT             Wavefront proxy port [#{DEFAULT_OPTS[:port]}]
  -T, --tag=TAG              point tag in key=value form
  -F, --infileformat=STRING  format of input file or stdin [#{DEFAULT_OPTS[:infileformat]}]
  -m, --metric=STRING        the metric path to which contents of a
                             file will be assigned. If the file
                             contains a metric name, the two will be
                             concatenated

Files are whitespace separated, and fields can be defined with the -F
option.  Use 't' for timestamp; 'm' for metric name; 'v' for value
and 'T' for tags. Put 'T' last.
),
source: %(
Usage:
  #{WF} source list [-c file] [-P profile] [-E endpoint] [-t token] [-DnV]
           [-f format] [-T tag ...] [-ag] [-s source] [-l limit] <pattern>
  #{WF} source show [-c file] [-P profile] [-E endpoint] [-t token] [-DnV]
           [-f format] <host> ...
  #{WF} source describe [-c file] [-P profile] [-E endpoint] [-t token]
           [-DnV] [-H host ... ] <description>
  #{WF} source undescribe [-c file] [-P profile] [-E endpoint] [-t token]
           [-DnV] [<host>] ...
  #{WF} source tag add [-c file] [-P profile] [-E endpoint] [-t token]
           [-DnV] [-H host ... ] <tag> ...
  #{WF} source tag delete [-c file] [-P profile] [-E endpoint] [-t token]
           [-DnV] [-H host ... ] <tag> ...
  #{WF} source untag [-c file] [-P profile] [-E endpoint] [-t token] [-DnV]
           [<host>] ...
  #{WF} source --help
#{global_opts}
Options:
  -E, --endpoint=URI         cluster endpoint [#{DEFAULT_OPTS[:endpoint]}]
  -t, --token=TOKEN          Wavefront authentication token
  -a, --all                  including hidden sources in 'human' output
  -g, --tags                 show tag counts in 'human' output
  -T, --tagged=STRING        only list sources with this tag when using
                             'human' output
  -s, --start=STRING         start the list after the named source
  -l, --limit=NUMBER         only list NUMBER sources
  -H, --host=STRING          source to manipulate
  -f, --sourceformat=STRING  output format (#{SOURCE_FORMATS.join(', ')}) [#{DEFAULT_OPTS[:sourceformat]}]
),
ts: %(
Usage:
  #{WF} ts [-c file] [-P profile] [-E endpoint] [-t token] [-ODnV]
            [-S | -m | -H | -d] [-s time] [-e time] [-f format] [-p num]
            [-X bool] <query>
#{global_opts}
Options:
  -E, --endpoint=URI            cluster endpoint [#{DEFAULT_OPTS[:endpoint]}]
  -t, --token=TOKEN             Wavefront authentication token
  -S, --seconds                 query granularity of seconds
  -m, --minutes                 query granularity of minutes
  -H, --hours                   query granularity of hours
  -d, --days                    query granularity of days
  -s, --start=TIME              start of query window in epoch seconds or
                                strptime parseable format
  -e, --end=TIME                end of query window in epoch seconds or
                                strptime parseable format
  -f, --format=STRING           output format (#{FORMATS.join(', ')})
                                [#{DEFAULT_OPTS[:format]}]
  -p, --prefixlength=NUM        number of path elements to treat as prefix
                                in schema manipulation. [#{DEFAULT_OPTS[:prefixlength]}]
  -X, --strict=BOOL             Do not return points outside the query
                                window. [#{DEFAULT_OPTS[:strict]}]
  -O, --includeObsoleteMetrics  include metrics unreported for > 4 weeks
),

default: %(
Wavefront CLI

Usage:
  #{WF} [options] command [options]
  #{WF} --version
  #{WF} --help

Commands:
  agent             view and manage Wavefront agents
  alert             view and manage alerts
  cloudintegration  view and manage cloud integrations
  dashboard         view and manage dashboards

  event             open and close events
  source            view and manage source tags and descriptions
  ts                view timeseries data
  write             send data points to a Wavefront proxy

Use '#{WF} <command> --help' for further information.)
}

# Parse the input. The first Docopt.docopt handles the default
# options, the second works on the command.
#
begin
  opts = Docopt.docopt(usage[:default], version: WF_CLI_VERSION)
rescue Docopt::Exit => e

  cmd = ARGV.empty? ? nil : ARGV.first.to_sym

  if usage.keys.include?(cmd)
    begin
      opts = sanitize_keys(Docopt.docopt(usage[cmd]))
    rescue Docopt::Exit => e
      abort e.message # command help
    end
  else
    abort e.message # default help
  end
end

opts = WavefrontCli::OptHandler.new(conf_file, opts).opts

if opts[:debug]
  require 'pp'
  puts 'Combined options:'
  pp opts
end

begin
  require "wavefront-cli/#{cmd}"
  klass_name = if class_names.key?(cmd.to_sym)
                 class_names[cmd.to_sym]
               else
                 cmd.capitalize
               end
  klass = Object.const_get('WavefrontCli').const_get(klass_name)
  cli = klass.new(opts)
rescue
  abort 'Fatal error. Unsupported command.'
end

=begin
case cmd
when :agent
  cli = WavefrontCli::Agent.new(opts)
when :alert
  cli = WavefrontCli::Alert.new(opts)
when :ts
  require 'wavefront-cli/ts'
  cli = WavefrontCli::Ts.new(opts, [opts[:'<query>']])
when :event
  require 'wavefront-cli/event'
  cli = WavefrontCli::Event.new(opts, [opts[:'<query>']])
when :source
  require 'wavefront-cli/source'
  cli = WavefrontCli::Sources.new(opts, [opts[:'<state>']])
when :write
  if opts[:file]
    require 'wavefront-cli/batch_write'
    cli = WavefrontCli::BatchWrite.new(opts, [opts[:'<state>']])
  else
    require 'wavefront-cli/write'
    cli = WavefrontCli::Write.new(opts, [opts[:'<state>']])
  end
when :dashboard
  require 'wavefront-cli/dashboard'
  cli = WavefrontCli::Dashboard.new(opts, [opts[:'<state>']])
end
=end

begin
  cli.validate_opts
  cli.run
rescue => e
  #if e.class == RestClient::MethodNotAllowed
    #STDERR.puts "#{cmd} query failed. #{e}"
  #elsif e.class.ancestors.include?(RestClient::ExceptionWithResponse)
    #STDERR.puts "#{cmd} query failed. #{e.http_code}: " +
                #JSON.parse(e.response)['status']['message'] + '.'
  #else
    STDERR.puts "general error: #{e}"
    STDERR.puts "re-run with '-D' for stack trace." unless opts[:debug]
  #end

  STDERR.puts "Backtrace:\n\t#{e.backtrace.join("\n\t")}" if opts[:debug]
  exit 1
end
